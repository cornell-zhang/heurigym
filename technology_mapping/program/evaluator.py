#!/usr/bin/env python3
"""
evaluator.py - cost evaluator for LUT-mapped BLIF designs.

Cost metric = total number of LUTs (“nodes”) reported by ABC.
"""

from __future__ import annotations

import argparse
import re
import shutil
import subprocess
from pathlib import Path
from typing import Final, Union

# ---------------------------------------------------------------------
# Regexes that cover both styles of ABC `ps` output
# ---------------------------------------------------------------------
_PS_SUMMARY_RE: Final = re.compile(r"\bnd\s*=\s*(\d+)\b")


def evaluate(input_file: str, solution_file: str) -> Union[int, float]:
    """
    Cost calculation function: calculates the cost.
    Suppose the input has been verified by the verifier, which means the input to this function is always valid.
    Please do NOT change the function name. You can take in more than one input file, but please keep the last argument as the solution file.
    It is used by the agent to evaluate the cost of the generated solution.

    Args:
        input_file: Path to the input file
        solution_file: Path to the output file generated by the solver

    Returns:
        Union[int, float]: The final cost

    """
    blif_path = Path(solution_file).expanduser().resolve()
    if not blif_path.is_file():
        raise FileNotFoundError(blif_path)
    return _get_nodes_via_abc(blif_path)


class ABCNotFoundError(RuntimeError):
    """Raised when the `abc` executable is missing on $PATH."""


def _get_nodes_via_abc(blif: Path) -> int:
    """Run ABC `ps` and return the LUT count (nodes)."""
    if shutil.which("abc") is None:
        raise ABCNotFoundError(
            "`abc` binary not found in $PATH. "
            "Install Berkeley ABC from https://github.com/berkeley-abc/abc"
        )

    cmd = ["abc", "-c", f"read_blif {blif.as_posix()}; ps"]
    proc = subprocess.run(
        cmd,
        text=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        check=True,
    )
    out = proc.stdout

    # Try modern summary style first
    m = _PS_SUMMARY_RE.search(out)
    if m:
        return int(m.group(1))


    raise RuntimeError(
        "Could not parse LUT count from ABC output:\n" + out
    )



if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Evaluate the LUT count of a mapped BLIF design."
    )
    parser.add_argument(
        "blif",
        type=Path,
        help="Path to the BLIF file produced by the mapper.",
    )
    args = parser.parse_args()
    lut_count = evaluate(None, args.blif) # input_file is not used
    print(f"# of LUTs = {lut_count}")
