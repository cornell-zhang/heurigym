"""
verifier.py - BLIF-to-BLIF equivalence checker using ABC's CEC engine.
"""

from __future__ import annotations

import argparse
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Tuple

def verify(input_file: str, solution_file: str) -> Tuple[bool, str]:
    """
    Verification function: checks if all the constraints are satisfied.
    Please do NOT change the function name. You can take in more than one input file, but please keep the last argument as the solution file.
    It is used by the agent to verify the output of the solver.

    Args:
        input_file: Path to the input file
        solution_file: Path to the output file generated by the solver

    Returns:
        Tuple[bool, str]: A tuple of (is_valid, error_message)
            - is_valid: True if the output is valid, False otherwise
            - error_message: If the output is invalid, please provide a detailed error message on why it is invalid;
            If the output is valid, please return an empty string.

    """
    # -- Pre-flight checks --------------------------------------------------
    golden = Path(input_file).expanduser().resolve()
    candidate = Path(solution_file).expanduser().resolve()

    # if the solution_file suffix is `.output`, copy this file to a new file with `.blif` suffix
    if candidate.suffix == ".output":
        new_candidate = candidate.with_suffix(".blif")
        # Copy the file to create a new one with `.blif` suffix
        shutil.copy(candidate, new_candidate)
        candidate = new_candidate

    error_message = ""

    if not golden.is_file():
        raise FileNotFoundError(f"Golden file not found: {golden}")
    if not candidate.is_file():
        raise FileNotFoundError(f"Candidate file not found: {candidate}")

    _check_abc_available()

    # -- Run CEC ------------------------------------------------------------
    proc = _run_cec(golden, candidate)
    output = proc.stdout

    # ABC exits with 0 if the `cec` command was successful.
    if proc.returncode == 0 and "Networks are equivalent" in output:
        return True, error_message
    elif proc.returncode == 0:
        error_message = output
        return False, error_message
    else:
        # verification failed. Raise an error.
        error_message = (
            f"ABC returned non-zero exit code {proc.returncode}.\n"
            f"Output:\n{output}"
        )
        raise RuntimeError(
            f"ABC CEC command failed with exit code {proc.returncode}.\n"
            f"Output:\n{output}"
        )



def _check_abc_available() -> None:
    """Raise RuntimeError if `abc` binary is not on PATH."""
    if shutil.which("abc") is None:
        raise RuntimeError(
            "`abc` executable not found on $PATH. "
            "Install Berkeley ABC (https://github.com/berkeley-abc/abc) "
            "or add it to your PATH before running the verifier."
        )


def _run_cec(golden: Path, candidate: Path) -> subprocess.CompletedProcess[str]:
    """Run `cec` in ABC and return the CompletedProcess."""
    cmd = [
        "abc",
        "-c",
        f"cec {golden.as_posix()} {candidate.as_posix()}"
    ]
    # capture both stdout and stderr as text, force locale-independent output
    return subprocess.run(
        cmd,
        check=False,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True
    )



# --------------------------------------------------------------------------
# Stand-alone usage: `python verifier.py golden.blif candidate.blif`
# --------------------------------------------------------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Verify logical equivalence between two BLIF files using ABC."
    )
    parser.add_argument("golden", help="Path to the reference (golden) BLIF net-list")
    parser.add_argument("candidate", help="Path to the candidate BLIF net-list produced by the mapper")
    parser.add_argument("--quiet", action="store_true", help="Suppress detailed error output")
    
    args = parser.parse_args()
    
    is_equiv, err_message = verify(args.golden, args.candidate)
    print("EQUIVALENT" if is_equiv else "NOT EQUIVALENT")
    if not is_equiv and not args.quiet:
        print(f"Error: {err_message}")
    sys.exit(0 if is_equiv else 1)
