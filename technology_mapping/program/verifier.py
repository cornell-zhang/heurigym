"""
verifier.py - BLIF-to-BLIF equivalence checker using ABC's CEC engine.
"""

from __future__ import annotations

import argparse
import re
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Tuple

def verify(input_file: str, solution_file: str, max_lut_size: int = 6) -> Tuple[bool, str]:
    """
    Verification function: checks if all the constraints are satisfied.
    Please do NOT change the function name. You can take in more than one input file, but please keep the last argument as the solution file.
    It is used by the agent to verify the output of the solver.

    Args:
        input_file: Path to the input file
        solution_file: Path to the output file generated by the solver
        max_lut_size: Maximum allowed LUT size (K), default is 6

    Returns:
        Tuple[bool, str]: A tuple of (is_valid, error_message)
            - is_valid: True if the output is valid, False otherwise
            - error_message: If the output is invalid, please provide a detailed error message on why it is invalid;
            If the output is valid, please return an empty string.

    """
    # -- Pre-flight checks --------------------------------------------------
    golden = Path(input_file).expanduser().resolve()
    candidate = Path(solution_file).expanduser().resolve()

    # if the solution_file suffix is `.output`, copy this file to a new file with `.blif` suffix
    if candidate.suffix == ".output":
        new_candidate = candidate.with_suffix(".blif")
        # Copy the file to create a new one with `.blif` suffix
        shutil.copy(candidate, new_candidate)
        candidate = new_candidate

    error_message = ""

    if not golden.is_file():
        raise FileNotFoundError(f"Golden file not found: {golden}")
    if not candidate.is_file():
        raise FileNotFoundError(f"Candidate file not found: {candidate}")

    _check_abc_available()

    # -- Check LUT size constraint ------------------------------------------
    is_valid_lut_size, lut_error = _check_lut_size(candidate, max_lut_size)
    if not is_valid_lut_size:
        return False, lut_error

    # -- Run CEC ------------------------------------------------------------
    proc = _run_cec(golden, candidate)
    output = proc.stdout

    # ABC exits with 0 if the `cec` command was successful.
    if proc.returncode == 0 and "Networks are equivalent" in output:
        return True, error_message
    elif proc.returncode == 0:
        error_message = output
        return False, error_message
    else:
        # verification failed. Raise an error.
        error_message = (
            f"ABC returned non-zero exit code {proc.returncode}.\n"
            f"Output:\n{output}"
        )
        raise RuntimeError(
            f"ABC CEC command failed with exit code {proc.returncode}.\n"
            f"Output:\n{output}"
        )



def _check_lut_size(candidate: Path, max_lut_size: int) -> Tuple[bool, str]:
    """
    Check if the candidate BLIF file satisfies the LUT size constraint.
    
    Args:
        candidate: Path to the candidate BLIF file
        max_lut_size: Maximum allowed LUT size (K)
    
    Returns:
        Tuple[bool, str]: (is_valid, error_message)
            - is_valid: True if all LUTs have fanin <= max_lut_size
            - error_message: Error message if constraint is violated, empty string otherwise
    """
    cmd = [
        "abc",
        "-c",
        f"read_blif {candidate.as_posix()}; print_fanio"
    ]
    
    proc = subprocess.run(
        cmd,
        check=False,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True
    )
    
    if proc.returncode != 0:
        raise RuntimeError(
            f"ABC print_fanio command failed with exit code {proc.returncode}.\n"
            f"Output:\n{proc.stdout}"
        )
    
    output = proc.stdout
    
    # Parse the output to extract max fanin
    # Looking for a line like: "Fanins: Max = 6. Ave = 5.48.  Fanouts: Max = 1. Ave =  1.00."
    match = re.search(r'Fanins:\s*Max\s*=\s*(\d+)', output)
    
    if not match:
        raise RuntimeError(
            f"Could not parse max fanin from ABC output.\n"
            f"Output:\n{output}"
        )
    
    max_fanin = int(match.group(1))
    
    if max_fanin > max_lut_size:
        error_message = (
            f"The output uses LUTs which have larger fanins than requirements. "
            f"The max fanin is {max_fanin}, which is larger than K={max_lut_size}"
        )
        return False, error_message
    
    return True, ""


def _check_abc_available() -> None:
    """Raise RuntimeError if `abc` binary is not on PATH."""
    if shutil.which("abc") is None:
        raise RuntimeError(
            "`abc` executable not found on $PATH. "
            "Install Berkeley ABC (https://github.com/berkeley-abc/abc) "
            "or add it to your PATH before running the verifier."
        )


def _run_cec(golden: Path, candidate: Path) -> subprocess.CompletedProcess[str]:
    """Run `cec` in ABC and return the CompletedProcess."""
    cmd = [
        "abc",
        "-c",
        f"cec {golden.as_posix()} {candidate.as_posix()}"
    ]
    # capture both stdout and stderr as text, force locale-independent output
    return subprocess.run(
        cmd,
        check=False,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True
    )



# --------------------------------------------------------------------------
# Stand-alone usage: `python verifier.py golden.blif candidate.blif`
# --------------------------------------------------------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Verify logical equivalence between two BLIF files using ABC."
    )
    parser.add_argument("golden", help="Path to the reference (golden) BLIF net-list")
    parser.add_argument("candidate", help="Path to the candidate BLIF net-list produced by the mapper")
    parser.add_argument("--quiet", action="store_true", help="Suppress detailed error output")
    
    args = parser.parse_args()
    
    is_equiv, err_message = verify(args.golden, args.candidate)
    print("EQUIVALENT" if is_equiv else "NOT EQUIVALENT")
    if not is_equiv and not args.quiet:
        print(f"Error: {err_message}")
    sys.exit(0 if is_equiv else 1)
