#!/usr/bin/env python3

# ABC baseline with command "if -a -K 6": to generate the 6-LUT mapping
# Usage: python run_abc.py <input_blif> <output_blif> [--verify] [--evaluate]
import argparse
import subprocess
import os
import shutil
import re
import sys
from pathlib import Path
from typing import Tuple, Union, Final

def run_abc_mapping(input_blif, output_blif, K=6):
    """
    Run ABC for LUT mapping with specified K value.
    
    Args:
        input_blif (str): Path to input BLIF file
        output_blif (str): Path to output BLIF file
        K (int): LUT size (default: 6)
    """
    # Construct ABC command
    abc_cmd = f'abc -c "read {input_blif}; if -a -K {K}; write_blif {output_blif}"'
    
    # Run ABC command
    try:
        subprocess.run(abc_cmd, shell=True, check=True)
        print(f"Successfully mapped {input_blif} to {output_blif} using K={K}")
    except subprocess.CalledProcessError as e:
        print(f"Error running ABC: {e}")
        raise

def verify(input_file: str, solution_file: str) -> Tuple[bool, str]:
    """
    Verification function: checks if all the constraints are satisfied.
    
    Args:
        input_file: Path to the input file
        solution_file: Path to the output file generated by the solver

    Returns:
        Tuple[bool, str]: A tuple of (is_valid, error_message)
            - is_valid: True if the output is valid, False otherwise
            - error_message: If the output is invalid, a detailed error message
    """
    # -- Pre-flight checks --------------------------------------------------
    golden = Path(input_file).expanduser().resolve()
    candidate = Path(solution_file).expanduser().resolve()

    # if the solution_file suffix is `.output`, copy this file to a new file with `.blif` suffix
    if candidate.suffix == ".output":
        new_candidate = candidate.with_suffix(".blif")
        # Copy the file to create a new one with `.blif` suffix
        shutil.copy(candidate, new_candidate)
        candidate = new_candidate

    error_message = ""

    if not golden.is_file():
        raise FileNotFoundError(f"Golden file not found: {golden}")
    if not candidate.is_file():
        raise FileNotFoundError(f"Candidate file not found: {candidate}")

    _check_abc_available()

    # -- Run CEC ------------------------------------------------------------
    proc = _run_cec(golden, candidate)
    output = proc.stdout

    # ABC exits with 0 if the `cec` command was successful.
    if proc.returncode == 0 and "Networks are equivalent" in output:
        return True, error_message
    elif proc.returncode == 0:
        error_message = output
        return False, error_message
    else:
        # verification failed. Raise an error.
        error_message = (
            f"ABC returned non-zero exit code {proc.returncode}.\n"
            f"Output:\n{output}"
        )
        raise RuntimeError(
            f"ABC CEC command failed with exit code {proc.returncode}.\n"
            f"Output:\n{output}"
        )

def _check_abc_available() -> None:
    """Raise RuntimeError if `abc` binary is not on PATH."""
    if shutil.which("abc") is None:
        raise RuntimeError(
            "`abc` executable not found on $PATH. "
            "Install Berkeley ABC (https://github.com/berkeley-abc/abc) "
            "or add it to your PATH before running the verifier."
        )

def _run_cec(golden: Path, candidate: Path) -> subprocess.CompletedProcess[str]:
    """Run `cec` in ABC and return the CompletedProcess."""
    cmd = [
        "abc",
        "-c",
        f"cec {golden.as_posix()} {candidate.as_posix()}"
    ]
    # capture both stdout and stderr as text, force locale-independent output
    return subprocess.run(
        cmd,
        check=False,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True
    )

# Regex for ABC `ps` output
_PS_SUMMARY_RE: Final = re.compile(r"\bnd\s*=\s*(\d+)\b")

def evaluate(input_file: str, solution_file: str) -> Union[int, float]:
    """
    Cost calculation function: calculates the cost.
    
    Args:
        input_file: Path to the input file
        solution_file: Path to the output file generated by the solver

    Returns:
        Union[int, float]: The final cost (number of LUTs)
    """
    blif_path = Path(solution_file).expanduser().resolve()
    if not blif_path.is_file():
        raise FileNotFoundError(blif_path)
    return _get_nodes_via_abc(blif_path)

class ABCNotFoundError(RuntimeError):
    """Raised when the `abc` executable is missing on $PATH."""

def _get_nodes_via_abc(blif: Path) -> int:
    """Run ABC `ps` and return the LUT count (nodes)."""
    if shutil.which("abc") is None:
        raise ABCNotFoundError(
            "`abc` binary not found in $PATH. "
            "Install Berkeley ABC from https://github.com/berkeley-abc/abc"
        )

    cmd = ["abc", "-c", f"read_blif {blif.as_posix()}; ps"]
    proc = subprocess.run(
        cmd,
        text=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        check=True,
    )
    out = proc.stdout

    # Try modern summary style first
    m = _PS_SUMMARY_RE.search(out)
    if m:
        return int(m.group(1))

    raise RuntimeError(
        "Could not parse LUT count from ABC output:\n" + out
    )

def main():
    parser = argparse.ArgumentParser(description='Run ABC for LUT mapping')
    parser.add_argument('input_blif', help='Input BLIF file path')
    parser.add_argument('output_blif', help='Output BLIF file path')
    parser.add_argument('--K', type=int, default=6, help='LUT size (default: 6)')
    parser.add_argument('--verify', action='store_true', help='Verify output equivalence')
    parser.add_argument('--evaluate', action='store_true', help='Evaluate LUT count')
    
    args = parser.parse_args()
    
    # Check if input file exists
    if not os.path.exists(args.input_blif):
        raise FileNotFoundError(f"Input file {args.input_blif} not found")
    
    # Create output directory if it doesn't exist
    output_dir = os.path.dirname(args.output_blif)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Run ABC mapping
    run_abc_mapping(args.input_blif, args.output_blif, args.K)
    
    # Verify if requested
    if args.verify:
        is_equiv, error_msg = verify(args.input_blif, args.output_blif)
        if is_equiv:
            print("VERIFICATION: EQUIVALENT")
        else:
            print(f"VERIFICATION: NOT EQUIVALENT\nError: {error_msg}")
            sys.exit(1)
    
    # Evaluate if requested
    if args.evaluate:
        lut_count = evaluate(args.input_blif, args.output_blif)
        print(f"EVALUATION: # of LUTs = {lut_count}")

if __name__ == "__main__":
    main()
